name: Changesets

on:
  workflow_run:
    workflows: [CI]
    types: [completed]
    branches: [master]

# Changesets Workflow for Automated Versioning and Publishing
#
# How it works:
# 1. Developer creates a changeset: `pnpm changeset`
# 2. Changeset file (.changeset/*.md) is committed and pushed
# 3. This workflow creates/updates a "Version Packages" PR
# 4. Maintainer reviews and merges the Release PR
# 5. On next push to master, packages are published to npm
#
# OIDC Trusted Publishing:
# - Uses npm Trusted Publishing with OIDC (no NPM_TOKEN required)
# - Requires Node.js 24+ (npm >= 11.5.1)
# - Each package must be configured on npmjs.com with Trusted Publisher:
#   * Provider: GitHub Actions
#   * Organization/User: greydragon888
#   * Repository: real-router
#   * Workflow: changesets.yml

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  packages: write
  id-token: write # Required for OIDC Trusted Publishing

# Turbo Remote Cache
env:
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ vars.TURBO_TEAM }}

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    # Only run if CI workflow succeeded
    if: github.event.workflow_run.conclusion == 'success'
    steps:
      - name: Checkout repo
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: pnpm
          # NOTE: Do NOT use registry-url here!
          # It creates .npmrc with ${NODE_AUTH_TOKEN} which conflicts with OIDC.

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check for changesets
        id: check
        run: |
          # Check if there are any changeset files (excluding README)
          CHANGESETS=$(find .changeset -name "*.md" ! -name "README.md" 2>/dev/null | wc -l | tr -d ' ')
          echo "changesets_count=$CHANGESETS" >> $GITHUB_OUTPUT
          echo "Found $CHANGESETS changeset(s)"

      # Extract PR/issue references from changeset files for Release PR title
      - name: Extract PR references
        if: steps.check.outputs.changesets_count != '0'
        id: refs
        run: |
          # Find all #XX references in changeset files (excluding README)
          REFS=$(grep -roh '#[0-9]\+' .changeset/*.md 2>/dev/null | sort -u | tr '\n' ' ' | xargs)
          if [ -n "$REFS" ]; then
            echo "refs= ($REFS)" >> $GITHUB_OUTPUT
            echo "Found PR references: $REFS"
          else
            echo "refs=" >> $GITHUB_OUTPUT
            echo "No PR references found in changesets"
          fi

      # If there are changesets, create/update the release PR
      - name: Create Release PR
        if: steps.check.outputs.changesets_count != '0'
        uses: changesets/action@6a0a831ff30acef54f2c6aa1cbbc1096b066edaf # v1.7.0
        with:
          version: pnpm run version
          title: "release: version packages${{ steps.refs.outputs.refs }}"
          commit: "release: version packages${{ steps.refs.outputs.refs }}"
          setupGitUser: false
        env:
          # Use PAT instead of GITHUB_TOKEN to trigger CI workflows on created PR
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
          # Skip husky hooks during release commit (CI already validated)
          HUSKY: 0
          GIT_AUTHOR_NAME: ${{ github.repository_owner }}
          GIT_AUTHOR_EMAIL: ${{ github.repository_owner }}@users.noreply.github.com
          GIT_COMMITTER_NAME: ${{ github.repository_owner }}
          GIT_COMMITTER_EMAIL: ${{ github.repository_owner }}@users.noreply.github.com

      # If no changesets, check if there are unpublished versions
      - name: Check for unpublished packages
        if: steps.check.outputs.changesets_count == '0'
        id: unpublished
        run: |
          echo "Checking for unpublished package versions..."
          UNPUBLISHED=""

          for dir in packages/*/; do
            if [ -f "$dir/package.json" ]; then
              name=$(node -p "require('./${dir}package.json').name")
              local_version=$(node -p "require('./${dir}package.json').version")
              private=$(node -p "require('./${dir}package.json').private || false")

              if [ "$private" = "true" ]; then
                echo "â­ï¸ $name is private, skipping"
                continue
              fi

              # Check if this version exists on npm
              npm_version=$(npm view "$name" version 2>/dev/null || echo "0.0.0")

              if [ "$local_version" != "$npm_version" ]; then
                echo "ðŸ“¦ $name: local=$local_version, npm=$npm_version (needs publish)"
                UNPUBLISHED="$UNPUBLISHED $name"
              else
                echo "âœ… $name: $local_version (already published)"
              fi
            fi
          done

          if [ -n "$UNPUBLISHED" ]; then
            echo "has_unpublished=true" >> $GITHUB_OUTPUT
            echo "packages=$UNPUBLISHED" >> $GITHUB_OUTPUT
          else
            echo "has_unpublished=false" >> $GITHUB_OUTPUT
          fi

      # Build and test before publishing
      - name: Build packages
        if: steps.unpublished.outputs.has_unpublished == 'true'
        run: pnpm build

      - name: Run tests
        if: steps.unpublished.outputs.has_unpublished == 'true'
        run: pnpm test

      # Publish with OIDC Trusted Publishing
      # changeset publish automatically:
      # - Checks which versions are not on npm
      # - Publishes in dependency order
      # - Skips already published (warns, doesn't fail)
      # - Creates git tags
      # - Uses pnpm publish (detects from lockfile)
      # Provenance is auto-generated with npm Trusted Publishing
      - name: Publish to npm
        if: steps.unpublished.outputs.has_unpublished == 'true'
        run: pnpm changeset publish

      - name: Push git tags
        if: steps.unpublished.outputs.has_unpublished == 'true'
        run: git push --tags

      # Create GitHub releases for each published package
      - name: Create GitHub Releases
        if: steps.unpublished.outputs.has_unpublished == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASES_CREATED=""

          for dir in packages/*/; do
            if [ -f "$dir/package.json" ]; then
              name=$(node -p "require('./${dir}package.json').name")
              version=$(node -p "require('./${dir}package.json').version")
              private=$(node -p "require('./${dir}package.json').private || false")

              if [ "$private" = "true" ]; then
                continue
              fi

              # Check if this version was just published (compare with npm)
              npm_version=$(npm view "$name" version 2>/dev/null || echo "0.0.0")

              if [ "$version" = "$npm_version" ]; then
                # Extract package directory name for CHANGELOG path
                pkg_dir=$(basename "$dir")
                changelog_path="${dir}CHANGELOG.md"
                tag="${name}@${version}"

                # Check if release already exists
                if gh release view "$tag" > /dev/null 2>&1; then
                  echo "â­ï¸ Release $tag already exists, skipping"
                  continue
                fi

                # Extract release notes from CHANGELOG (content between first ## and second ##)
                if [ -f "$changelog_path" ]; then
                  NOTES=$(awk '/^## /{if(found) exit; found=1; next} found{print}' "$changelog_path")
                else
                  NOTES="Release ${version}"
                fi

                # Determine if prerelease
                PRERELEASE_FLAG=""
                if echo "$version" | grep -q "-"; then
                  PRERELEASE_FLAG="--prerelease"
                fi

                echo "ðŸ·ï¸ Creating release: $tag"
                gh release create "$tag" \
                  --title "$name@$version" \
                  --notes "$NOTES" \
                  $PRERELEASE_FLAG

                RELEASES_CREATED="$RELEASES_CREATED $tag"
                echo "âœ… Created release: $tag"
              fi
            fi
          done

          if [ -n "$RELEASES_CREATED" ]; then
            echo "RELEASES_CREATED=$RELEASES_CREATED" >> $GITHUB_ENV
          fi

      - name: Summary
        run: |
          echo "## Changesets Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.check.outputs.changesets_count }}" != "0" ]; then
            echo "âœï¸ Found ${{ steps.check.outputs.changesets_count }} changeset(s)" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“ Release PR created/updated" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.unpublished.outputs.has_unpublished }}" = "true" ]; then
            echo "ðŸ“¦ Published packages:${{ steps.unpublished.outputs.packages }}" >> $GITHUB_STEP_SUMMARY
            if [ -n "$RELEASES_CREATED" ]; then
              echo "ðŸ·ï¸ Created releases:$RELEASES_CREATED" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âœ… All packages are up to date" >> $GITHUB_STEP_SUMMARY
          fi
