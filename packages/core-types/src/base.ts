// packages/core-types/modules/base.ts

// Note: RouteTreeState is exported from route-node-types.ts
// It uses RouteParams as default type parameter.
// Real Router code should use RouteTreeState<Params> when needed.

export type Unsubscribe = () => void;

export interface SimpleState<P extends Params = Params> {
  name: string;
  params: P;
}

export type TransitionPhase = "deactivating" | "activating";

export type TransitionReason = "success" | "blocked" | "cancelled" | "error";

export interface TransitionMeta {
  phase: TransitionPhase;
  from?: string;
  reason: TransitionReason;
  blocker?: string;
  segments: {
    deactivated: string[];
    activated: string[];
    intersection: string;
  };
}

export interface State<P extends Params = Params, MP extends Params = Params> {
  name: string;
  params: P;
  path: string;
  meta?: StateMeta<MP> | undefined;
  transition?: TransitionMeta | undefined;
}

export interface StateMeta<P extends Params = Params> {
  id: number;
  params: P;
  options: NavigationOptions;
}

/**
 * Input type for makeState meta parameter.
 * Omits `id` since it's auto-generated by makeState.
 */
export type StateMetaInput<P extends Params = Params> = Omit<
  StateMeta<P>,
  "id"
>;

/**
 * RouterError interface describing the public API of the RouterError class.
 * The actual class implementation is in the real-router package.
 * This interface enables structural typing compatibility between
 * core-types and real-router packages.
 */
export interface RouterError extends Error {
  [key: string]: unknown;
  readonly code: string;
  readonly segment: string | undefined;
  readonly path: string | undefined;
  readonly redirect: State | undefined;
  setCode: (code: string) => void;
  setErrorInstance: (err: Error) => void;
  setAdditionalFields: (fields: Record<string, unknown>) => void;
  hasField: (key: string) => boolean;
  getField: (key: string) => unknown;
  toJSON: () => Record<string, unknown>;
}

/**
 * Configuration options that control navigation transition behavior.
 *
 * @description
 * NavigationOptions provides fine-grained control over how the router performs navigation
 * transitions. These options affect history management, transition lifecycle execution,
 * guard enforcement, and state comparison logic.
 *
 * All options are optional and have sensible defaults. Options can be combined to achieve
 * complex navigation behaviors. The options object is stored in state.meta.options and is
 * available to guards and event listeners.
 *
 * @see {@link Router.navigate} for navigation method that accepts these options
 * @see {@link State.meta} for where options are stored after navigation
 */
export interface NavigationOptions {
  [key: string]:
    | string
    | number
    | boolean
    | Record<string, unknown>
    | undefined;

  /**
   * Replace the current history entry instead of pushing a new one.
   *
   * @description
   * When `true`, the navigation will replace the current entry in browser history instead
   * of adding a new entry. This is typically used by history plugins (browser plugin) to
   * control how navigation affects the browser's back/forward buttons.
   *
   * @default false
   *
   * @example
   * // Redirect after login - prevent back button to login page
   * router.navigate('dashboard', {}, { replace: true });
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState}
   */
  replace?: boolean | undefined;

  /**
   * Force reload of the current route even if states are equal.
   *
   * @description
   * When `true`, bypasses the "same state" check that normally prevents navigation when
   * the target state equals the current state. This forces a full transition lifecycle
   * execution, allowing route components to reload with the same parameters.
   *
   * Without `reload`:
   * - Navigation to current route throws SAME_STATES error
   * - No lifecycle hooks execute
   * - No events are fired
   *
   * With `reload`:
   * - Full transition executes (deactivate → activate)
   * - All lifecycle hooks run again
   * - TRANSITION_SUCCESS event fires with same state
   * - State object is recreated (new reference)
   *
   * @default false
   *
   * @example
   * // Refresh current page data
   * router.navigate(currentRoute.name, currentRoute.params, { reload: true });
   *
   * @example
   * // Force re-fetch on same route with different query params
   * // Note: query params are in path, not checked for equality
   * router.navigate('search', { term: 'react' }, { reload: true });
   *
   * @see {@link force} for alternative that forces transition
   * @see {@link Router.areStatesEqual} for state comparison logic
   */
  reload?: boolean | undefined;

  /**
   * Force navigation even if target state equals current state.
   *
   * @description
   * When `true`, bypasses the "same state" equality check but still executes the full
   * transition lifecycle. Similar to `reload` but can be used
   * for any forced navigation scenario.
   *
   * Difference from `reload`:
   * - `reload`: semantic meaning is "refresh current route"
   * - `force`: general-purpose bypass of equality check
   * - Both have identical implementation effect
   *
   * The equality check compares:
   * - state.name (route name)
   * - state.params (route parameters, shallow comparison)
   *
   * @default false
   *
   * @example
   * // Force transition for tracking even if params didn't change
   * router.navigate('analytics', { event: 'pageview' }, { force: true });
   *
   * @see {@link reload} for semantic equivalent (preferred for refresh scenarios)
   */
  force?: boolean | undefined;

  /**
   * Skip canDeactivate guards during transition.
   *
   * @description
   * When `true`, bypasses only the canDeactivate lifecycle hooks for segments being
   * deactivated. canActivate guards still execute normally. This allows
   * forcing navigation away from routes with confirmation dialogs or unsaved changes.
   *
   * Skipped vs executed:
   * ```
   * // Normal transition
   * deactivate(fromSegments) → activate(toSegments) → success
   *
   * // With forceDeactivate: true
   * [skip deactivate] → activate(toSegments) → success
   * ```
   *
   * ⚠️ Data loss risk: Bypassing canDeactivate means unsaved changes will be lost
   *
   * @default false
   *
   * @example
   * // Force logout even with unsaved changes
   * function forceLogout() {
   *   router.navigate('login', {}, {
   *     forceDeactivate: true,
   *     replace: true
   *   });
   * }
   *
   * @see {@link Router.clearCanDeactivate} for programmatically clearing guards
   */
  forceDeactivate?: boolean | undefined;

  /**
   * Internal flag indicating navigation is result of a redirect.
   *
   * @internal
   *
   * @description
   * Automatically set by the router when a navigation is triggered by a redirect from
   * guards or lifecycle hooks. This flag is used internally to track redirect chains
   * and is stored in state.meta.options.redirected.
   *
   * @default false (auto-set by router during redirects)
   *
   * @example
   * // Accessing redirect flag in lifecycle
   * router.addActivateGuard('dashboard', (toState, fromState) => {
   *   if (toState.meta?.options?.redirected) {
   *     console.log('This navigation is from a redirect');
   *   }
   *   return true;
   * });
   *
   * @see {@link Router.navigate} for redirect handling implementation
   * @see {@link NavigationOptions.redirected} for the input mechanism
   */
  redirected?: boolean | undefined;
}

export interface Params {
  [key: string]:
    | string
    | string[]
    | number
    | number[]
    | boolean
    | boolean[]
    | Params
    | Params[]
    | Record<string, string | number | boolean>
    | null
    | undefined;
}
